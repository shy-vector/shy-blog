---
title: 有效数字，浮点数，规格化，以及渐进式下溢
published: 2025-11-08
updated: 2025-11-08
description: '手把手教你发明 IEEE 754 浮点数~'
image: ''
tags: [CSAPP]
category: 'CSAPP'
draft: false
---

# 手把手教你发明 IEEE 754 浮点数

## 有效数字

受限于存储位数 $n$ 的限制，机器只能存储 $2^n \, \text{bit}$ 的有限信息，反映在存储小数上就是只能表示有理数，无法表示无限不循环小数，即无理数。

:::note[惜墨如金]
考虑这样一个十进制无符号的情景：你只能写 6 个数字，以及 1 个小数点。你会怎样表示小数？
:::

你可能会行中庸之道：3 位整数，3 位小数。这样你就能表示 $[0, 999.999]$ 内，精度为 $0.001$ 的所有小数。

你可能不满于值域大小，于是你重新安排：5 位整数，1 位小数。这样你就能表示 $[0, 99999.9]$ 内，精度为 $0.1$ 的所有小数。

你可能不满于精度大小，于是你重新安排：1 位整数，5 位小数。这样你就能表示 $[0, 9.99999]$ 内，精度为 $0.00001$ 的所有小数。

:::tip[trade-off]
位数有限，所含信息也是有限的，你必然会在值域与精度之间做出权衡。
:::

直接做出向上面一样死板的安排（定点数）并非良策，但你会发现：上面三种方法都有一个共性：所表示的小数，**其有效位数是一样的**，都是 6 位有效数字，**仅小数点的位置不同**。

如果我们留出一些位数，来表示小数点的位置信息，是不是就能兼顾值域和精度，打破鱼和熊掌之僵局？

恭喜你，你发明了浮点数。

:::note[科学计数法]
实际上你会发现，科学计数法就是浮点的思想：
$$
\begin{align*}
1.2345 \times 10^3 &= 1234.5 \\
1.2345 \times 10^1 &= 12.345 
\end{align*}
$$
这样我们就实现了仅牺牲 1 位的有效数字表示小数点位置，带来了值域和精度的灵活调节。
:::

## 浮点数

:::tip[trade-off]
这个时候你又发现，究竟要从有效位数中挪用多少位（指数位）来表示小数点位置？
:::

这又是一种权衡：有效位数与小数点的浮动位数之间的权衡。遗憾的是，这种权衡没有灵活的空间，只能依靠主观了。

> 在六、七十年代，各家计算机公司的各个型号的计算机，有着千差万别的浮点数表示，却没有一个业界通用的标准。这给数据交换、计算机协同工作造成了极大不便。

车同轨，书同文。对于二进制浮点数，IEEE 754 规定：

| 总位数 | 符号 | 阶码（浮动位数） | 尾数（有效位数） |
|--------|------|------|------|
| 32 | 1 | 8 | 23 |
| 64 | 1 | 11 | 52 |

:::tip[一种可能的数学直觉]
为什么这样分呢？这跟对两者的价值评判有关：我们对值域大小和有效位数的感知都是线性的。

相比增加一位尾数以提供多一位有效数字，增加一位阶码所带来的值域大小，其收益是指数级别的，因此所安排的阶码位数应该是对数级别的。
:::

## 规格化

### 尾数部分

既然使用一个数来表示小数点浮动到的位置，那么浮动的原点在哪？

:::note[小数点的家]
让我们回到十进制的情景：
$$
000000005678912345072101145141919810000000
$$
你认为浮动的锚点定在哪比较合适？
:::

回想起我们的科学计数法：
$$
a \times 10^\text{exp}, \quad 1 \le |a| < 10
$$
所以按照我们的书写习惯：
$$
000000005.678912345072101145141919810000000
$$

> 你有没有想过为什么不是 $0 \le |a| < 1$？这在数学上看起来似乎更自然？
> $$
> 0.567891234507210114514191981
> $$
> 第一个 $0$ 没有提供有效信息，可以省略。可能是人们觉得小数点前面没有数字很奇怪吧，索性就规定前面应该有一个非零数字。

可在二进制中，为什么不这样做呢？
$$
.1101101010101101010010111101
$$
这样便是我们熟悉的定点小数。

但你很快发现：第一个 $1$ 是无效信息，因为如果第一个小数位是 $0$ 的话，就不是有效数字了，所以第一位小数非 $0$ 即 $1$，没有信息，这跟十进制的情况不同。

所以第一位小数是可以省略的，那干脆直接沿用我们的科学计数法吧：$1 \le |a| < 2$，第一位有效数字必为 $1$，直接省略。

综上所述，在二进制中，浮动的原点应紧跟在第一个 $1$ 的后面。

### 阶码部分

确定好浮动的原点后，我们的小数点应该能左右浮动，因此需要用有符号整数来表示浮动的位数。

那么该选用哪一种从有符号整数到无符号阶码的编码方案呢？

> 你可能选择使用补码：相比原码和反码，补码既能避免 $\pm \, 0$ 的冗余编码，又能方便人类阅读正整数，还能方便机器判断译码正负。

但你会发现，阶码不需要给人类阅读，也不需要机器判断正负以确定浮动方向（浮点数运算只需要阶码之间的相对大小信息，不需要正负信息）。

能避免 $\pm \, 0$ 的编码方案还有**移码**，它还能方便机器判断两个浮点数的阶码相对大小：仅需无符号整数的比较方法，无需最高位特判。

> 这还会带来一个好处：在浮点数中，如果规定阶码放在尾数的上游，那么在两个浮点数的非符号部分，只需按照字典序就能直接判断浮点数的相对大小。

比如对于 8 位阶码而言，译码方案应该是：
$$
[0, 255] \rightarrow [-127, 128]
$$

> 为什么不是 $[-128, 127]$？
>
> 可能因为指数为 $128$ 的浮点数可以用来表示一些特殊值，比如正负无穷、`NaN`，后文将提及。

## 非规格化

看似完美的浮点方案，却隐含着致命缺陷：

:::note[一个简单的任务]
如何表示 $0$ ？
:::

你傻眼了：因为 $0$ 根本没有有效数字，连浮动的锚点都找不到。

但你总不能一直用最小值 $1. \times 2^{-127}$ 来近似 $0$ 吧，那我们就直接规定一个 Magic Number 吧！

> 规定 `0 00000000 00000000000000000000000` 和 `1 00000000 00000000000000000000000` 分别译成 $\pm \, 0$。

但新的问题又产生了：前一脚 `0 00000000 00000000000000000000001` 还表示着 $(1 + 2^{-23}) \times 2^{-127}$，后一脚 `0 00000000 000000000000000000000000` 直接表示 $0$，会不会太突然了？

:::warning[有多突然？]
$$
\frac{(1 + 2^{-23}) \times 2^{-127} - 0}{(1 + 2^{-23}) \times 2^{-127} - 1 \times 2^{-127}} = 2^{23} + 1
$$
:::

### 渐进式下溢

工程师们也觉得这太突然了，于是想到一个办法：

> 从 `0 00000001 00000000000000000000000` 到 `0 00000000 00000000000000000000000`，这是过渡时期。

如何平稳过渡这段时期呢？工程师们选择放弃 $2^{-127}$ 的精度，从 $1 \times 2^{-126}$ 到 $0 \times 2^{-126}$ 之间直接**线性**过渡。具体而言，`0 00000001 00000000000000000000000` 译成 $1 \times 2^{-126}$，`0 00000000 11111111111111111111111` 并不译成 $(2 - 2^{-23}) \times 2^{-127}$，而是 $(1 - 2^{-23}) \times 2^{-126}$，原先整数部分省略的 $1$ 变成了 $0$。

:::tip[从指数渐降到线性直降]
尾数部分每减一次 $1$，都会带来整体值 $2^{-23} \times 2^\text{exp}$ 的降低，在同一指数级别是线性的，但在跨越不同指数级别的情况下，整体还是指数缓降的，不能很好地贴近 $0$。

于是我们规定：从最低指数级别往后，**保持降低幅度**，不再发生指数程度的减小，这样就能避免 “飞机” 在低空的持续飞行，实现着陆。
:::

这就是从最小规格化值变到最大非规格化值的时候，阶码值保持不变，比原本继续下溢相比多移了一位的原因。

形式上看，如果**阶码为 0**，则浮点数是非规格化的。

## 特殊值

我们在阶码全为 $1$ 的浮点数中，选取一些 Magic Number 来表示特殊值：

1. 无穷：尾数全 $0$，符号决定无穷的正负；
2. `NaN`：尾数非全 $0$，表示非数（Not a Number），比如 $\sqrt{-1}$，$\infty - \infty$。

